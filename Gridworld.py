class Gridworld:
    
    # States are a pair of row, column coordinates
    
    def initial_state(self):
    # return the initial state of this MDP
        initial_state = [5,1]        # used an array that is mutable (we can update this)
        return initial_state
    
    def states(self):
    # return a list containing all the possible states in this MDP
        states = [(1,1), (1,3), (1,4), (1,5), (2,1), (2,3), (2,4), (2,5), (3,1), (3,2),
                    (3,3), (3,4), (3,5), (4,1), (4,5), (5,1), (5,2), (5,3), (5,4), (5,5)]
        return states
    
    def actions(self):
    # return possible actions
        actions = ['U','D','L','R']
        return actions
    
    def reward(self, state, action, next_state):
    # return R(s, a, s ')    
        if next_state == (1,3) and state != (1,3):
            reward = 25
        else:
            reward = -1
        return reward
        
    def next_state(self, state, action):
        stateSpace = {(1,1):{'U':(1, 1), 'D':(2, 1), 'L':(1, 1), 'R':(1, 1)}, 
                  (1,3):{'U':(1, 3), 'D':(1, 3), 'L':(1, 3), 'R':(1, 3)}, 
                  (1,4):{'U':(1, 4), 'D':(2, 4), 'L':(1, 3), 'R':(1, 5)}, 
                  (1,5):{'U':(1, 5), 'D':(2, 5), 'L':(1, 4), 'R':(1, 5)}, 
                  (2,1):{'U':(1, 1), 'D':(3, 1), 'L':(2, 1), 'R':(2, 1)}, 
                  (2,3):{'U':(1, 3), 'D':(3, 3), 'L':(2, 3), 'R':(2, 4)}, 
                  (2,4):{'U':(1, 4), 'D':(3, 4), 'L':(2, 3), 'R':(2, 5)}, 
                  (2,5):{'U':(1, 5), 'D':(3, 5), 'L':(2, 4), 'R':(2, 5)}, 
                  (3,1):{'U':(2, 1), 'D':(4, 1), 'L':(3, 1), 'R':(3, 2)}, 
                  (3,2):{'U':(3, 2), 'D':(3, 2), 'L':(3, 1), 'R':(3, 3)},
                  (3,3):{'U':(2, 3), 'D':(3, 3), 'L':(3, 2), 'R':(3, 4)}, 
                  (3,4):{'U':(2, 4), 'D':(3, 4), 'L':(3, 3), 'R':(3, 5)}, 
                  (3,5):{'U':(2, 5), 'D':(4, 5), 'L':(3, 4), 'R':(3, 5)}, 
                  (4,1):{'U':(3, 1), 'D':(5, 1), 'L':(4, 1), 'R':(4, 1)}, 
                  (4,5):{'U':(3, 5), 'D':(5, 5), 'L':(4, 5), 'R':(4, 5)}, 
                  (5,1):{'U':(4, 1), 'D':(5, 1), 'L':(5, 1), 'R':(5, 2)}, 
                  (5,2):{'U':(5, 2), 'D':(5, 2), 'L':(5, 1), 'R':(5, 3)}, 
                  (5,3):{'U':(5, 3), 'D':(5, 3), 'L':(5, 2), 'R':(5, 4)}, 
                  (5,4):{'U':(5, 4), 'D':(5, 4), 'L':(5, 3), 'R':(5, 5)},
                  (5,5):{'U':(4, 5), 'D':(5, 5), 'L':(5, 4), 'R':(5, 5)}}
        
        return stateSpace[state][action]
        
    def pr(self, state, action, next_state):
        # return P(s' | s, a)

        #probabilities is a dictionary, referencing each existing state
        # assume if in state (1,3), it will not escape
        probabilities={(1,1):{'U':(1, 1), 'D':(2, 1), 'L':(1, 1), 'R':(1, 1)}, 
                      (1,3):{'U':(1, 3), 'D':(1, 3), 'L':(1, 3), 'R':(1, 3)}, 
                      (1,4):{'U':(1, 4), 'D':(2, 4), 'L':(1, 3), 'R':(1, 5)}, 
                      (1,5):{'U':(1, 5), 'D':(2, 5), 'L':(1, 4), 'R':(1, 5)}, 
                      (2,1):{'U':(1, 1), 'D':(3, 1), 'L':(2, 1), 'R':(2, 1)}, 
                      (2,3):{'U':(1, 3), 'D':(3, 3), 'L':(2, 3), 'R':(2, 4)}, 
                      (2,4):{'U':(1, 4), 'D':(3, 4), 'L':(2, 3), 'R':(2, 5)}, 
                      (2,5):{'U':(1, 5), 'D':(3, 5), 'L':(2, 4), 'R':(2, 5)}, 
                      (3,1):{'U':(2, 1), 'D':(4, 1), 'L':(3, 1), 'R':(3, 2)}, 
                      (3,2):{'U':(3, 2), 'D':(3, 2), 'L':(3, 1), 'R':(3, 3)},
                      (3,3):{'U':(2, 3), 'D':(3, 3), 'L':(3, 2), 'R':(3, 4)}, 
                      (3,4):{'U':(2, 4), 'D':(3, 4), 'L':(3, 3), 'R':(3, 5)}, 
                      (3,5):{'U':(2, 5), 'D':(4, 5), 'L':(3, 4), 'R':(3, 5)}, 
                      (4,1):{'U':(3, 1), 'D':(5, 1), 'L':(4, 1), 'R':(4, 1)}, 
                      (4,5):{'U':(3, 5), 'D':(5, 5), 'L':(4, 5), 'R':(4, 5)}, 
                      (5,1):{'U':(4, 1), 'D':(5, 1), 'L':(5, 1), 'R':(5, 2)}, 
                      (5,2):{'U':(5, 2), 'D':(5, 2), 'L':(5, 1), 'R':(5, 3)}, 
                      (5,3):{'U':(5, 3), 'D':(5, 3), 'L':(5, 2), 'R':(5, 4)}, 
                      (5,4):{'U':(5, 4), 'D':(5, 4), 'L':(5, 3), 'R':(5, 5)},
                      (5,5):{'U':(4, 5), 'D':(5, 5), 'L':(5, 4), 'R':(5, 5)}}
        
        if next_state == probabilities[state][action]:
            prob = 1
        else:
            prob = 0
    
        return prob
    
    def set_p(self, p):
        self.p = p